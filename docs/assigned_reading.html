<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Assigned Reading- Breiman – Graduate Work Product</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-33042ce356e75f275e6de0b8c71cd0b0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
h1, h2, h3 {
  font-weight: 400 !important;
  color: #2c3e50;
}
h2 {
  font-size: 1.35rem !important;
  margin-top: 1.5rem;
}
h3 {
  font-size: 1.15rem !important;
}
.quarto-title-meta-heading {
  font-size: 0.8rem;
  font-weight: 400;
  text-transform: uppercase;
  color: #7f8c8d;
}
.quarto-title-meta-contents {
  font-size: 0.8rem;
  color: #7f8c8d;
}
</style>


</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Graduate Work Product</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-coursework" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Coursework</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-coursework">    
        <li class="dropdown-header">KNOWLEDGE MINING</li>
        <li>
    <a class="dropdown-item" href="./syllabi/knowledge_mining_syllabus.pdf">
 <span class="dropdown-text">— Syllabus</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./knowledge_mining_notes.html">
 <span class="dropdown-text">— Lecture Notes</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">ASSIGNMENT 1</li>
        <li>
    <a class="dropdown-item" href="./assignment_1_files/Lab01.html">
 <span class="dropdown-text">Lab 01: Report</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./assignment_1_files/Lab02.html">
 <span class="dropdown-text">Lab 02: Report</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">ASSIGNMENT 2</li>
        <li>
    <a class="dropdown-item" href="./Assignment 2/assignment_2.html">
 <span class="dropdown-text">Systematic Literature Review</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li>
    <a class="dropdown-item" href="./assigned_reading.html">
 <span class="dropdown-text">Assigned Reading</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">QUANTITATIVE METHODS</li>
        <li>
    <a class="dropdown-item" href="./syllabi/quantitative_methods_syllabus.pdf">
 <span class="dropdown-text">— Syllabus</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./quantitative_methods.html">
 <span class="dropdown-text">— Lecture Notes</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/AdileneGaribay/knowledge_mining"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#section" id="toc-section" class="nav-link active" data-scroll-target="#section"></a></li>
  <li><a href="#section-1" id="toc-section-1" class="nav-link" data-scroll-target="#section-1"></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Assigned Reading- Breiman</h1>
</div>



<div class="quarto-title-meta">

    
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">February 2, 2026</p>
    </div>
  </div>
    
  </div>
  


</header>


<section id="section" class="level2">
<h2 class="anchored" data-anchor-id="section"></h2>
<p>Reading Material</p>
<p><a href="pdfs/breiman_statistical_modeling.pdf">{{&lt; fa file-pdf &gt;}} Click here to download/view the article: Breiman - Statistical Modeling</a></p>
</section>
<section id="section-1" class="level2">
<h2 class="anchored" data-anchor-id="section-1"></h2>
<p>Notes &amp; Review</p>
<p>There are two cultures in statistical modeling. The first is dependent on stochastic data models, and the other on algorithmic models. Breiman (2001) argues that algorithmic models can be utilized on large, complex data sets to provide more accurate information. Consequently, the author suggests a shift away from a heavy dependence on stochastic data models.</p>
<p>In data analysis, Breiman (2001) identifies two primary goals: prediction and information. Prediction involves estimating the responses of future input variables. The second goal, information, entails extracting insight into how nature associates response variables with input variables. In the data modeling culture, a stochastic model is assumed to exist inside the “black box.” The values of the parameters are estimated from the data, and the model is then used for information or prediction. This model is typically validated using goodness-of-fit tests and residual examination. Breiman (2001) notes that approximately 98% of statisticians focus their efforts on this stochastic data model method.</p>
<p>In contrast, the algorithmic model considers the interior of the black box to be complex and unknown. This approach focuses on finding an algorithm that operates on input&nbsp;x&nbsp;to predict the responses of&nbsp;y. The validation of this model is measured by its predictive accuracy. According to Breiman (2001), only about 2% of the statistical community utilizes this method.</p>
<p>Breiman makes three primary arguments. For one, traditional data modeling has led to irrelevant theory and questionable conclusions. It has kept statisticians from using more suitable algorithmic models. Lastly, it has prevented statisticians from working on exciting new problems.</p>
<p>Breiman uses the Ozone project to illustrate the limitations of traditional modeling. In the Ozone project, the EPA sought to predict ozone levels 12 hours in advance to provide more timely public alerts. Ozone levels were known to be influenced by meteorological conditions in prior days, making the task dependent on complex environmental patterns. Researchers attempted to build a predictive model that would use available variables to forecast the following day’s ozone levels. To complete this, the first 5-years of data were used as a training set and the last two were used as a test set. Large linear regressions were run and variable selections were conducted. Ultimately, the project failed. Breiman presents this failure as evidence of the limitations of traditional data modeling approaches when applied to complex, real-world prediction problems.</p>
<p>Breiman uses an example from an EPA project to illustrate how traditional data modeling approaches struggle with high-dimensional data. The goal of the chlorine project was to predict whether a chemical compound contains chlorine using its mass spectrum. Mass spectra provide information about a compound’s structure, but interpreting them typically requires substantial effort from experienced chemists, making the process costly and time-consuming. The project resulted in a database containing known chemical structures and mass spectra for approximately 30,000 compounds. Researchers attempted to use this database to automate the classification of compounds as chlorine or non-chlorine. Traditional statistical methods, including linear and quadratic discriminant analysis, were applied but proved difficult to adapt due to the high dimensional of the predictor variables. When algorithmic modeling approaches, particularly decision trees, were used instead, the classification accuracy improved substantially, reaching about 95% for both chlorine and non-chlorine compounds.</p>
<p>Statisticians focus too much on data models. Nature is complex, and it is unrealistic to believe that a statistician can fully and accurately specify the parameters and mechanisms that generate real-world data. Breiman uses an example to show that once a data-generating model is assumed, it becomes easy to derive hypothesis tests, goodness-of-fit measures, and confidence intervals. This mathematical convenience makes data models attractive. However, significance levels for coefficients are often derived with little consideration of whether the data could plausibly have been generated by a linear model. As a result, measures such as R squared are computed without adequately checking model validity, which can lead to incorrect conclusions.</p>
<p>Current practice for checking model fit relies on goodness-of-fit measures and residual analysis. Breiman conducts a simulation study using regression with controlled departures from linearity in seven dimensions. Standard goodness-of-fit tests did not reject linearity until the departures were extreme. Tinkering with the model based on the observed data invalidates the use of goodness-of-fit tests. Residual analysis is also unreliable, as it cannot uncover lack of fit in more than four or five dimensions. In higher dimensions, interactions among variables can produce passable residual plots for a variety of models. Thus, an acceptable residual plot does not imply that the model provides a good representation of the data. Breiman argues that evaluating how well a model fits the observed data is less important than assessing its predictive performance.</p>
<p>The goal of statisticians is often to uncover the underlying mechanisms that produce the data. Data modeling attempts to achieve this by providing a simple and interpretable description of the relationship between input and response variables. However, the same dataset can be well fit by multiple models, each of which offers a different interpretation of the underlying mechanism.</p>
<p>To see how well a model emulates nature’s box, put&nbsp;XX&nbsp;into nature’s box and observe the output&nbsp;YY. Then put the same&nbsp;XX&nbsp;into the model box and get&nbsp;Y^Y^. Comparing the two outputs shows how well the model emulates nature. The extent to which a model box reproduces nature’s box measures how well the model captures the natural phenomenon generating the data. Breiman also discusses the bias of using too many parameters, which can overfit the data and give a biased estimate of predictive accuracy. Bias can be reduced using methods such as cross-validation. For large datasets, a separate test set can be held out. Breiman argues for the need to evaluate models using&nbsp;<strong>predictive accuracy</strong>&nbsp;rather than solely relying on goodness-of-fit.</p>
<p>There is a new research community that focuses on neural networks and decision trees. The goal of this field is&nbsp;<strong>predictive accuracy</strong>. Researchers began developing tools for complex prediction problems where traditional data models were clearly inadequate, such as speech recognition, image recognition, nonlinear time series prediction, handwriting recognition, and prediction in financial markets.</p>
<p>The approach in this field rarely uses data models. Instead, it treats nature as a black box, whose workings are complex, mysterious, and partly unknowable. The problem is to find an algorithm such that, for future&nbsp;XX&nbsp;in a test set,&nbsp;f(X)f(X)&nbsp;is a good predictor of&nbsp;YY. This theory shifts the focus from modeling the data to studying the properties of algorithms, emphasizing their strengths as predictors, their iterative convergence, and what contributes to their predictive accuracy. The only assumption is that the data are drawn from an unknown multivariate distribution.</p>
<p>There have been three important lessons to learn from the field on machine learning: Rashomon; the multiplicity of good models; Occam: the conflict between simplicity and accuracy; &amp; Bellman: dimensionality-curse or blessing.</p>
<p>The Rashomon Effect refers to the existence of a multitude of different functions within a class of functions that achieve approximately the same minimum error rate. For example, suppose there are 300 variables and we want the best 5-variable linear regression. There are about 140,000 subsets in competition. If we select the model with the lowest residual sum of squares, or, when using a test set, the lowest prediction error, there may still be many subsets within 1% of the minimum RSS.</p>
<p>The Rashomon Effect also occurs with decision trees and neural networks. For trees, even a slight perturbation of the training set—such as removing only 2–3% of the data—can produce a tree that is quite different from the original, yet has nearly the same test set error. This instability arises when many different models are crowded together with similar training or test errors. Small changes in the data or model construction can cause a jump from one model to another. These models are close in error but distant in form.</p>
<p>Occam’s Razor states that simpler models are better. In prediction, simplicity and accuracy can clash.</p>
<p>Instead of using a single tree, a forest of trees is grown. An input&nbsp;xx&nbsp;is passed down each tree, and each tree votes for a predicted class. The class receiving the most votes is the forest’s prediction. There are well-known methods for growing forests, such as perturbing the training set, growing a tree on the perturbed data, perturbing the data again, and growing another tree. Breiman’s preferred method is random forests, in which successive decision trees are grown by introducing randomness into their construction through random selection.</p>
<p>Comparing forests to single trees, forests have a significantly lower error rate because they average the predictions of many unstable trees, reducing variance while maintaining flexibility.</p>
<p>The Statlog Project compared 18 different classifiers. Random forests ranked first overall, with an average rank of 1, demonstrating their strong predictive performance.</p>
<p>Occam’s dilemma is that forests are excellent predictors, but their prediction mechanisms are difficult to interpret. High predictive accuracy generally requires complex methods, while simple and interpretable functions tend to be less accurate. Breiman argues that the soundest path is to prioritize predictive accuracy. In goal-oriented statistics, Occam’s dilemma does not exist.</p>
<p>Bellman and the curse of dimensionality. Rejects this claim. Argues that dimensionality means more informatioin for predcition,</p>
<p><strong>Disclosure:</strong> I utilized <strong>Gemini 3 Flash</strong> for technical assistance with Quarto website formatting and file structure; however, all intellectual content and writing in the “Notes &amp; Review” section are my own original work.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>